import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";
import { createSelector } from "@reduxjs/toolkit";
export const api = createApi({
  refetchOnFocus: true, //will refetch when the tab of the browser is focused on
  refetchOnReconnect: true, // will refetch when the browser's network is reconnected
  tagTypes: ["services", "dogs"],
  //keepUnusedDataFor: 5, // after 5 seconds in a url that not depend on the dogs / services automatically will remove cached data from the browser and if we come back to the page it will fetch the data again
  baseQuery: fetchBaseQuery({
    baseUrl: "/api",
    //this needed if we want both global and endpoint    headers to be shown
    /* prepareHeaders: (headers) => {
      headers.set("x-custom-header",Math.random());
      return headers;
    }, */
    //headers: {},method: "GET", we can add custom headers here also
  }),
  endpoints: (builder) => ({
    getServices: builder.query({
      query: () =>
        // "/services" if we don't need to add custom headers
        ({
          url: "/services",
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        }),
      // declaring an endpoint  to fetch data from /api/services using this costume hook that automatically generated by rtk-query useGetServicerQuery
      //always will return data as a data this way we rename it as data: services
      // keepUnusedDataFor: 5, // and we can set to only one of the endpoints
    }),

    getService: builder.query({
      query: (id) => `/services/${id}`,
    }),
    makeContact: builder.mutation({
      query: (formBody) => ({
        url: "/contact",
        method: "POST",
        body: formBody,
      }),
    }),
    getDogs: builder.query({
      query: () => "/dogs",
      transformResponse: (dogs) => {
        const allDogs = {};
        for (const id in dogs) {
          const dog = dogs[id];
          allDogs[id] = {
            ...dog,
            size: getSize(dog.weight),
            age: getAge(dog.dob),
          };
        }
        return allDogs;
      },
      providesTags: ["dogs"],
    }),
    addDog: builder.mutation({
      query: (formBody) => ({
        url: "/dogs",
        method: "POST",
        body: formBody,
      }),
      invalidatesTags: ["dogs"],
    }),
    removeDog: builder.mutation({
      query: (id) => ({
        url: `/dogs/${id}`,
        method: "DELETE",
      }),
      invalidatesTags: ["dogs"],
      /* 
      When the query starts, when we kick off our removeDog mutation, we're going to receive the ID.
      Then we're going to dispatch this very, very, very special Redux action, api.util.updateQueryData. We're updating the getDogsQuery when no argument is passed in(undefined is passed ). The way that we're going to update it is by deleting the dog with this ID.
      */
      onQueryStarted(id, { dispatch, queryFulfilled }) {
        const update = dispatch(
          api.util.updateQueryData("getDogs", undefined, (dogs) => {
            delete dogs[id];
          })
        );
        queryFulfilled.catch((error) => {
          update.undo();
        });
      },
    }),
  }),
});

export const {
  useGetServicesQuery,
  useGetServiceQuery,
  useMakeContactMutation,
  useGetDogsQuery,
  useAddDogMutation,
  useRemoveDogMutation,
} = api;

export const getServicesForLuckyDog = createSelector(
  api.endpoints.getServices.select(),
  api.endpoints.getDogs.select(),
  (state) => state.dogs.luckyDog,
  ({ data: services }, { data: dogs }, luckyDog) => {
    const dog = dogs?.[luckyDog];
    if (!dog) return services;
    return services
      .filter(({ restrictions }) => {
        return restrictions.minAge ? dog.age >= restrictions.minAge : true;
      })
      .filter(({ restrictions }) => {
        return restrictions.breed
          ? restrictions.breed.includes(dog.breed)
          : true;
      })
      .filter(({ restrictions }) => {
        return restrictions.breed ? restrictions.size.includes(dog.size) : true;
      });
  }
);
// utilities

export function getSize(weight) {
  weight = parseInt(weight, 10);
  if (weight <= 10) return "teacup";
  if (weight <= 25) return "small";
  if (weight <= 50) return "medium";
  if (weight <= 80) return "large";
  if (weight <= 125) return "x-large";
  return "jumbo";
}

const YEAR = 3.156e10;
export function getAge(dob) {
  const date = +new Date(dob);
  return Math.floor((Date.now() - date) / YEAR);
}
